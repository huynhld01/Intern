
#include <stdio.h>
#include <time.h>
#include <signal.h>
#include <string.h>
#include <stdlib.h>

#include <termios.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include "snake.h"


int kfd = 0;
struct termios cooked, raw;

/* default direction = UP */
char dir = KEYCODE_U; 
int score;
int level = 1;

unsigned char map[17][17] = {0}; // Game map
unsigned char snake[50] = {133}; // Initialize the snake coordinates. At the beginning of the game, the snake is at (8,5).
unsigned char food = 67; // The coordinates of the food, at the beginning of the game at (4,3)
int length = 1; // save the current length of the snake
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
 /* Get keyboard response: up, down, left, right */
void* get_dir()
{	
	while(1)
	{
		//char c;     
		/* Get the termios structure saved, then reconfigure the terminal */                                                         
		tcgetattr(kfd, &cooked);
		memcpy(&raw, &cooked, sizeof(struct termios));
		raw.c_lflag &=~ (ICANON | ECHO);                       
		raw.c_cc[VEOL] = 1;
		raw.c_cc[VEOF] = 2;
		tcsetattr(kfd, TCSANOW, &raw);
		
		pthread_mutex_lock(&mutex);
		if(read(kfd, &dir, 1) < 0)
		{
			perror("read():");
			exit(-1);
		}
		pthread_mutex_unlock(&mutex);
		/* Restore the original configuration at the end of the program */
		tcsetattr(kfd, TCSANOW, &cooked);
		//pthread_mutex_lock(&mutex);
		//dir = c;
		//pthread_mutex_unlock(&mutex);
	}
	pthread_detach(pthread_self());
}






 // convert the number to a coordinate system
void num_to_xy(unsigned char num, unsigned char *x, unsigned char *y)
{
	*x = num >> 4;
	*y = (unsigned char)(num << 4) >> 4;
}

 // Generate food
unsigned char generate_food()
{
	srand ((unsigned int)time(NULL)); // Generate a seed of a random number
	unsigned char new_food;
	unsigned char x,y;
	int insnake = 0; // The food generated by the flag is not in the body of the snake, the default is not
	do
	{
		insnake = 0;
     
		new_food = rand() % 256; // Produce a new food
      
		num_to_xy(new_food, &x, &y);
		
		int i;
		for (i = 0; i < length; i++)
		{
			if (snake[i] == new_food)
			{
				insnake = 1; // 1 represents the body of the snake
				break;
			}
		}	
	}while (x == 0 || x == 16 || y == 0 || y == 16 || insnake);
	
	return new_food;
}



 // update map data
void display()
{	
	int i, j;
	unsigned char x,y; // coordinates
	num_to_xy(snake[0], &x, &y); // Get the coordinates of the snake head
	for (i = 0; i < 17; i++)
	{
		for (j = 0; j < 17; j++)
		{
			if (i == 0 || i == 16 ) // represents the boundary of the map
			{
				map[i][j] = '+';
			}
			else if (j == 0 || j == 16)
			{
				map[i][j] = '+';
			}
			else
			{
				map[i][j] = ' ';
			}
			
		}
	}
	 // Determine the direction of movement
	switch (dir)
	{
		 case KEYCODE_U: // move up
			y--;
			break;
		 case KEYCODE_D: // move down
			y++;
			break;
		 case KEYCODE_L: // move left
			x--;
			break;
		 case KEYCODE_R: // move to the right
			x++;
			break;
		 case KEYCODE_Q: // quit
		 	clrscr();
			textcolor(WHITE);
		 	printf("Quiz Game");
			break;
	}
	 unsigned char last = snake[0]; // save the value of the original snake head
	 snake[0] = (unsigned char)(x << 4) + y; // update the snake head coordinates
	


	 // move the body of the snake
	unsigned char current;
	for (i = 1; i < length; i++)
	{
		current  = snake[i];
		snake[i] = last;
		last = current;
	}
	
	 // If the coordinates of the snake head and the food coincide, prove that the snake eats the food.
	 // len is the length of the snake 0 -- len-1 snake[len]
	if (snake[0] == food)
	{
		score++;
		if (0 == score % 5)
			level += 1;
		 // The snake has a long body
		snake[length] = last;
		length += 1;
		 // Regenerate food
		food = generate_food();
	}

    textcolor(YELLOW);
	printf("score %d  ", score);
	textcolor(LIGHTBLUE);
	printf("level %d\n", level);
	// Initialize the boundary first
	

	 // Initialize food
	 num_to_xy(food, &x, &y); // Get the coordinates of the food (4,3)
	 map[y][x] = '@'; // Set food
	
	
	 // Initialize the snake
	for (i = 0; i < length; i++)
	{
		num_to_xy(snake[i], &x, &y); // Get the coordinates of the snake's i+1th body
      	textcolor(LIGHTCYAN);
		map[y][x] = '*';
	}
	
	for (i = 0; i < 17; i++)
	{
		for (j = 0; j < 17; j++)
		{
			printf ("%c", map[i][j]);
		}
		printf ("\n");
	}
	
	 usleep(500000/(length/6+1)); // Let the program sleep for 1 second
	 system("clear"); // Clear screen
}






 // Determine if the snake should survive. If the return value is 0, it should survive. 1 means it should not survive.
int isalive()
{
	unsigned char x,y;
	num_to_xy(snake[0], &x, &y); // Get the coordinates of the snake head
	
	// Determine if the snake head has touched the border
	if (x == 0 || x == 16 || y == 0 || y == 16)
	{
		return 1;
	}
	 // Determine if the snake head has bitten it
	int i;
	for (i = 1; i < length; i++)
	{
		if (snake[0] == snake[i])
		{
			return 1;
		}
	}
	return 0;
}

int main()
{	
	pthread_t tid1;

   	pthread_create(&tid1,NULL,get_dir, NULL);

	while (1)
	{
		display();
		if (isalive() == 1)
			break;
	}	
	tcsetattr(kfd, TCSANOW, &cooked);//Restore the original configuration at the end of the program
	printf("GameOver...\n");
	return 0;
}